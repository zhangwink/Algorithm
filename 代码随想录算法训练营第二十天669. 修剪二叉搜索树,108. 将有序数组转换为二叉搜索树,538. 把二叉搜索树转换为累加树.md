# 代码随想录算法训练营第二十天|[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/),[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/),[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)



> 文档:[代码随想录](https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)
>
> 状态:一刷



---

## 题目:

### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

![20201014173115788](https://file1.kamacoder.com/i/algo/20201014173115788.png)

**思路:**

​	简单来说就是在这个二叉搜索树中遍历去寻找在这个区间范围内的元素,例如如果root的值大于high就要递归右子树,看看右子树有没有符合的并返回结点,root小于low就遍历右子树看看有没有符合的返回,当在符合条件之后就去找子树左右符合条件的

**递归三部曲**

- 确定递归函数的返回值与参数
  - 最后返回结点以作修改

代码如下:

```c++
TreeNode* trimBST(TreeNode* root, int low, int high)
```

- 确定终止条件
  - 修建操作不在终止条件进行,遇到空结点返回即可

代码如下:

```c++
if (root == nullptr) return nullptr;
```

- 确定单层递归的逻辑



- 如果root元素小于low值,那么应该递归右子树,返回右子树符合条件的头结点

代码如下:

```c++
if (root->val < low){
  TreeNode* right = trimBST(root->right, low, high);
  return right;
}
```

- 如果root元素大于high的值,那么应该递归左子树,返回左子树符合条件的头结点

代码如下:

```c++
if (root->val > high){
  TreeNode* left =trimBST(root->left, low, high);
  return left;
}
```

- 接下来就要将下一层处理完的左子树结果赋给root->left,处理完的右子树的结果赋给root->right,返回root结点,代码如下:

```c++
root->left = trimBST(root->left, low, high);
root->right = trimBST(root->right, low, high);
return root;
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

![20201022164420763](https://file1.kamacoder.com/i/algo/20201022164420763.png)

**思路**:

可以用双指针的思路来遍历数组,因为这是一个二叉搜索,中序遍历之后与数组相当



**递归三部曲:**

- 确定递归函数的返回值及参数

​	删除二叉树结点,增加二叉树结点,都使用递归函数的返回值来完成的

代码如下:

```c++
// 左闭右闭区间[left, right]
TreeNode* traversal(vector<int>& nums, int left, int right)
```



- 确定终止条件

​	因为用双指针,递归终止条件一目了然,所以当区间 left > right的时候，就是空节点了。

```c++
if (left > right) return nullptr;
```



- 确定单层递归的逻辑

​	首先取数组中间元素的位置，不难写出`int mid = (left + right) / 2;`，**这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，在[二分法 (opens new window)](https://programmercarl.com/0035.搜索插入位置.html)中尤其需要注意！**

所以可以这么写：`int mid = left + ((right - left) / 2);`

但本题leetcode的测试数据并不会越界，所以怎么写都可以。但需要有这个意识！

取了中间位置，就开始以中间位置的元素构造节点，代码：`TreeNode* root = new TreeNode(nums[mid]);`。

接着划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点。

代码如下:

```c++
int mid = left + ((right - left) / 2);
TreeNode* root = new TreeNode(nums[mid]);
root->left = traversal(nums, left, mid - 1);
root->right = traversal(nums, mid + 1, right);
return root;
```





### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)









![20201023160751832](https://file1.kamacoder.com/i/algo/20201023160751832.png)

- 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
- 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]



**思路:**

例如给你输入一个[2,5,13] ,输出之后应该为[20,18,13],这样可以好理解,即对这个二叉搜索树可以右左中遍历,即反中序遍历就可以了



**递归三部曲:**

- 递归函数参数及其返回值

这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。

同时需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为int型就可以了。

代码如下：

```c++
int pre= 0;
void traversal(TreeNode* cur)
```



- 确定终止条件

遇空就终止

```c++
if (cur == NULL) return;
```



- 确定单层递归逻辑

从思路开始看顺序我们应该右中左顺序遍历这个子树,中结点的处理逻辑就是让cur的数值加上前一个结点的值

代码如下:

```c++
travelsal(cur->right);
cur->val +=pre;
pre =cur ->val;
traversal(cur->left);
```

---



## 总结:

今天系统学习修剪二叉树,了解了如何在二叉搜索树限制大小的问题,如果小于最小值就去找右子树,反之;

学会如何从有序数组转为二叉搜索树,更深入的了解递归的本质,更注重解决的问题,不用去想递归(可能会好理解点吧)

认识了二叉搜索树转变为累加树的过程,可以理解为右中的遍历(二轮继续复习)

