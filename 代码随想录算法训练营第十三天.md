# 代码随想录算法训练营第十三天

> 文档:[代码随想录](https://docs.qq.com/doc/DUHN0ZVJuRmVYeWNv?nlc=1)
>
> 状态:一刷

## 题目:

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/):

递归三部曲:

1.确定递归函数的参数和返回值:

参数就是要穿入节点的指针返回值就是要传入root结点的指针

```java
TreeNode * invertTree(TreeNode* root)
```

2.确定终止条件

```java
if (root == NULL) return root;
```



3.确定单层递归的逻辑

使用前序遍历,中左右,所以先交换左右孩子结点,然后返回左子树,反转右子树.

```java
swap(root->left,root->right);
invertTree(root->left);
invertTree(root->right);
```



java代码:

```java
class Solution{
  public TreeNode invertTree (TreeNode root){
    if (root == null){
			return null;
    }
    invertTree(root.left);
    invertTree(root.right);
    swapChildren (root);
    return root;
  }
  
  private void swapChildren(TreeNode root){
    TreeNode tmp =root.left;
    root.left =root.right;
    root.right =tmp;
  }
}
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/):

递归三部曲

1.确定递归函数的参数和返回值

```java
bool compare(TreeNode *left ,TreeNode *right)
```

2.确定终止条件

1. 结点为空的情况

   - 左结点为空 ,右结点不为空 ,不对称,return false
   - 左不为空,右结点为空return false
   - 左右结点都为空,return true

2. 结点不为空

   - 左右都不为空,比较结点值,不相同就return false

   此时左右结点都不为空,且数值也不相同的情况我们也处理了

   ```java
   if (left == NULL && right != NULL) return false;
   else if (left != NULL && right == NULL) return false;
   else if (left ==NULL &&right ==NULL)return true;
   else if (left->val !=right->val) return false;
   ```

   

3.确定单层递归的逻辑

- 比较二叉树外侧是否对成,比较的是传进来的左结点的左孩子,右结点的右孩子
- 比较内侧是否对称,传入左节点的右孩子,右结点的左孩子
- 比较左右都对称就返回true,有一侧不对称就返回false

代码如下:

```java
bool outside =compare (left->left ,right ->right);
bool inside =compare (left ->right ,right ->left);
bool isSame =outSide && inside;
```



java代码如下:

```java
public boolean isSymmetric1(TreeNode root) {
        return compare(root.left, root.right);
    }

    private boolean compare(TreeNode left, TreeNode right) {

        if (left == null && right != null) {
            return false;
        }
        if (left != null && right == null) {
            return false;
        }

        if (left == null && right == null) {
            return true;
        }
        if (left.val != right.val) {
            return false;
        }
        // 比较外侧
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/):

递归三部曲:

1.确定递归函数的参数和返回值

```c++
int getdepth (TreeNode *node)
```

2.确定终止条件

```c++
if (node == null )return 0;
```

3.确定单层递归的逻辑

```c++
int leftdepth =getdepth (node->left);
int rightdepth = getdepth (node ->right);
int depth =1+max(leftdepth,rightdepth);
return depth;
```

