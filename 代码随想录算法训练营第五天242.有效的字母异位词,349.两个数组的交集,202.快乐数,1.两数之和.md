# 代码随想录算法训练营第五天|242.有效的字母异位词,349.两个数组的交集,202.快乐数,1.两数之和

> 文档:[代码随想录](https://docs.qq.com/doc/DUEtFSGdreWRuR2p4?nlc=1)
>
> 状态:
>
> 目的:理解哈希表内部的实现原理,哈希函数,哈希碰撞,常见哈希的区别,数组,set,map

## 哈希表理论基础:

哈希表:**根据关键码的值进行访问的数据结构**

eg:**数组就是一张哈希表**

哈希表中的关键就是数组的索引下标,然后通过下标直接访问元素,如下图所示:

![截屏2025-10-14 19.21.21](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-14 19.21.21.png)

***哈希表的作用:***

一般哈希表用来快速判断一个元素是否出现在集合里main

例如:要查询一个名字是否在这个学校里面 

枚举的话时间复杂度是O(n),但如果使用哈希表的话,O(1)就可以做到.

我们只需要初始化所有学校里学生的名字存在哈希表里main 查询时通过索引就可以知道![截屏2025-10-14 19.25.18](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-14 19.25.18.png)

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场

**哈希碰撞:**

![截屏2025-10-14 19.29.59](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-14 19.29.59.png)

如图所示:小李和小王都映射到了索引下标1的位置 这一现象就叫做哈希碰撞

有两种解答:**拉链法和探测法**

**拉链法:**

![截屏2025-10-14 19.31.51](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-14 19.31.51.png)

小李和小王在索引1发生了冲突 ,发生冲突的元素都被存储在链表中 这样我们可以通过索引找到小王和小李

**探测法:**

![截屏2025-10-14 19.33.29](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-14 19.33.29.png)

​	例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了





**常见的三种哈希结构:**

- 数组
- set(集合)
- map(映射)

我准备先用最简单的理解方式:

- 当我们使用集合来解决哈希表的时候 优先使用unorded_set因为他的查询和增删效率是最高的,试过需要集合是有序的,那就用set,如果不仅有序还有重复数据的话 那就用multiest
- map是一个(key,value)的数据结构 在map中,对key是有限制的 对value没限制 因为key的存储方式是红黑树实现的

## 题目:

#### 1.[两数之和](https://leetcode.cn/problems/two-sum/description/):

暴力解法我做过了就不在这里做了

先强调哈希的使用时机:

我们需要查询一个元素是否出现过,或者一个元素是否在集合里的时候就要第一时间想到哈希

本题我们就需要一个集合来存放我们遍历过的元素 然后再遍历数组的时候去访问他 ,某元素是否遍历过 即是否出现在这个集合

因此本题使用(key,value)map,至于set哈希为什么不能使用 因为我们这题不仅需要知道元素是否遍历过即元素是否在集合里 还需要知道元素的下表位置

接下来是map中key和value分别表示什么。

这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。

那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。

因此**map结构为**{key:数据元素,value:数组元素对应的下标}

因此代码如下

```java
//使用哈希表
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int [ ]res =new int [2];
      if (nums==null||nums.length==null){
        return res;
      }
      Map<Integer,Integer>map=new HashMap<>();
      for (int i =0;i<nums.length;i++){
        int temp =target-nums[i];
        if (map.containsKey(tmp)){
					res[1]=i;
          res[0]=map.get[tmp]
        }
        map.put(nums[i],i);
      }
      return res;
    }
}
```

