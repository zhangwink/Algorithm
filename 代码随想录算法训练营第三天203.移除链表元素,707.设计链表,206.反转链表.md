# 代码随想录算法训练营第三天|203.移除链表元素,707.设计链表,206.反转链表

> 文档讲解:[代码随想录](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)
>
> 状态:浏览完文档,视频未刷

## 链表理论基础

​	**链表**:是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

​	单链表中的指针域只能指向节点的下一个节点。

​	双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

​	双链表 既可以向前查询也可以向后查询。![截屏2025-10-12 19.04.52](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-12 19.04.52.png)

​	循环链表:就是链表首尾相连。![截屏2025-10-12 19.05.26](/Users/zzp/Library/Application Support/typora-user-images/截屏2025-10-12 19.05.26.png)

**链表的存储方式:**

数组在内存中是连续分布的 ,链表在内存中在内存中不是连续分布的,是散乱分布在内存中的某一个地址上



**链表的定义**:

```java
public class ListNode{
  //结点的值
  int val;
  
  //下一个结点的值
  ListNode next;
  
  //结点的函数构造(无参)
  public ListNode(){
    
  }
  
  //结点的构造函数(有参)
  public ListNode(int val){
    this.val=val;
  }
}
```



**链表的方法 :**

增删改查:(这些都比较熟悉,此次为了节省时间,先省略)



## 题目

### [**203.移除链表元素**](https://leetcode.cn/problems/remove-linked-list-elements/description/)

由于学过数据库 所以所有的链表我都会选择去增加一个虚拟头结点,来使链表操作简单

```cpp
//这个是一个基本的使用虚拟头结点来操作链表删除val相同的元素
class Solution {
    public ListNode removeElements(ListNode head, int val) {
     	ListNode *dummyHead =new ListNode(0);//	设置了一个虚拟头结点
      dummyHead->next =head;
      ListNode* cur =dummyHead;
      while(cur->next!=null){
				if (cur->next->val==val){
          ListNode*tmp=cur->next;
          cur->next=cur->next->next;
          delete tmp;
        }else{
          cur =cur->next;
        }
      }
      head =dummyHead->next;
      delete dummHead;
      return head;
    }
}
```

看完代码随想录:

利用递归的方法:(10.12 对于递归还没有掌握)

```java
class{
	public ListNode remoeElements (ListNode head,int val){
    if (head==null){
      return head;
    }
    
    head.next=removeElements(head.next,val);
    if (head.val==val){
      return head.next;
    }
    return head;
  }
}
```

### 707.[**设计链表**](https://leetcode.cn/problems/design-linked-list/description/)

这是一道数据结构的题(时间不充裕,我准备先用单链表,下一次在学双链表)

```java
class MyLinkedList {
  
  	class ListNode {
			int val;
      ListNode next;
      ListNode (int val){
        this.val=val;
      }
    }
  
  	//size存储的元素个数
  	private int size;
  	//记录虚拟头结点
  	private ListNode head;

    public MyLinkedList() {
      this.size=size;
     	this.head=new ListNode(0); 
    }
    
    public int get(int index) {
        if (index<0||index>=size){
          return -1;
        }
      ListNode cur =head;
      for (int i=0;i<=index;i++){
        cur=cur.next;
      }
      return cur.val;
    }
    
    public void addAtHead(int val) {
      ListNode newNode =new ListNode(val);
     	newNode.next=head.next;
      head.next=newNode;
      size++;
    }
    
    public void addAtTail(int val) {
      ListNode newNode =new ListNode(val);
    	ListNode cur =head;
      while (cur.next!=null){
				cur=cur.next;
      }
      cur.next=newNode;
      size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (index<0||index>size){
          return;
        }
      	
      ListNode pre =head;
      for (int i=0;i<index;i++){
        pre=pre.next;
      }
      ListNode newNode =new ListNode(val);
      newNode.next=pre.next;
      pre.next=newNOde;
      size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        
        //因为有虚拟头节点，所以不用对index=0的情况进行特殊处理
        ListNode pre = head;
        for (int i = 0; i < index ; i++) {
            pre = pre.next;
        }
        pre.next = pre.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 206.[反转链表](https://leetcode.cn/problems/reverse-linked-list/description/):

第一想法:

这是一个反转链表的题 但是链表是单向的 我想逆转能想到的方法就是把他先存到和他一样大小的数组或者栈里面然后再输出给一个新链表

代码如下:

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //遍历链表到数组
      	List<Integer>arr = new ArrayList<>();
      	ListNode cur =head;
      	while (cur!=null){
          arr.add(cur.val);
          cur=cur.next;
        }
      
      //根据数组构建反转后的新链表
      ListNode dummy =new	 ListNode(0);
      cur=dummy;
      for	(int i=arr.size()-1;i>=0;i--){
				cur.next=new ListNode(arr.get(i));
        cur=cur.next;
      }
      
      return dummy.next;
    }
}
```

看完代码随想录之后:

666算法太伟大了:

用pre从null开始,cur指向head,tmp保存临时的cur.next然后依次运算666

```java
//双指针
class sloution{
  public LisNode reverseList(Listode head){
    ListNode prev =null;
    ListNode cur =head;
    ListNode temp =null;
    while(cur!=null){
      tmp=cur.next;
      cur.next=prev;
      prev =cur;
      cur=tmp;
    }
    return prev;
  }
}
```





## 总结:

更深入的理解了数据结构里的虚拟头结点的重要性 学会操作链表结构 最重要学会了链表逆转的理念 非常的神奇 但对于递归我依然不熟悉 之后去多深入了解一下
