# 代码随想录算法训练营第四天|24.两两交换链表中的结点,19.删除链表的倒数第N个结点,面试题02.07.链表相交,142.环形链表

> 文档学习:[代码随想录](https://docs.qq.com/doc/DUFNjYUxYRHRVWklp?nlc=1)
>
> 视频学习:[代码随想录](https://www.bilibili.com/video/BV1YT411g7br/?vd_source=536f01d8d7a74e18b43740216a40d3aa)
>
> 状态:

## 题目:

### 24.[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/):

第一想法:

这个和前面的206有点像,都是逆转链表的思路

看完代码随想录:

想的差不多 主要问题在于不知道何时停止 继续移动

```java
class Solution{
  public ListNode swapPairs(ListNode head){
    ListNode dummyHead =new LIstNode (-1);
		dummyHead.next=head;
    ListNode cur =dummyhead;
    ListNode tmp;//临时结点 保存两个结点后面的结点
    ListNdoe firstNode ;//临时结点 保存两个结点中的第一个结点
    ListNode secondNode ;//临时结点 保存两个结点中的第二个结点
    while (cur.next!=null&&cur.next.next!=null){
      tmp=cur.next.next.next;
      firstNode=cur.next;
      secondNode=cur.next.next;
      cur.next=secondNode;
      secondNode.next=firstNode;
      firstNode.next=tmp;
      cur=firstNode;
    }
    return dummyHead.next;
  }
}
```

这个递归版本我还没看 ,今天有点忙 先到这里

```java
// 递归版本
class Solution {
    public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```

### 19.[删除链表的倒数第N个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/):

代码随想录:

这个算法主要考察链表的寻址 但不是一般的寻址 她需要找到倒数的位置,与数组不同的是,不能直接判断元素位数 所以这题采用双指针法(我感觉是滑动窗口),其思路是先移动N个位置fastIndex在同时开始移动slowIndex于fastIndex直到fastIndex到null

其代码如下:

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
       //新建虚拟指针
      ListNode dummyNode =new ListNode(0);
      dummyNode.next=head;
      
      //开始定义快慢指针
      ListNode fastIndex =dummyNode;
      ListNode slowIndex =dummyNode;
      
      //只要快慢指针
      for (int i=0;i<=n;i++){
        fastIndex =fastIndex.next;
      }
      
      while (fastIndex !=null){
        fastIndex =fastIndex.next;
        slowIndex =slowIndex.next;
      }
      
      
      if (slowIndex.next!=null){
        slowIndex.next =slowIndex.next.next;
      }
      return dummyNode.next;
    }
}
```

### [面试题02.07.链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/):

题目是说给两个链表让你相交:

相交就是说链表一样

思路是什么:

首先想一定是以最短的链表长度为基准 要不然什么都无从说起 

第一步就是:移动最长的那个链表cur倒数到最短的那个长度

第二步就是:同时移动 找头结点对应的链表相等 不相等就往后移动head,如果找不到就null;

因此代码如下:

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
      ListNode curA =headA;
      LIstNode curB =headB;
      int lenA=0,lenB=0;
      while (curA!=null){
				lenA++;
        curA=curA.next;
      }
      
      while (curB!=null){
        lenB++;
        curB=curB.next;
      }
      
      curA=headA;
      curB=headB;
      
      //确保curA为最长链表的头,lenA为其长度
      if (lenB>lenA){
				//swap a,b
        int tmpLen=LenA;
        lenA=lenB;
        lenB=tmpLen;
        
        //swap(curA,curB)
        ListNdoe tmpNode =curA;
        curA=curB;
        curB=tmpNdoe;
        
      }
      
      //求长度差
      int gap =lenA-lenB;
      //让curA和curB末对其;
      while(gap-->0){
        curA =curA.next;
      }
      
      //便遍历curA和curB,遇到相同直接返回
      while (curA!=null){
        if (curA==curB){
          return curA;
        }
        curA=curA.next;
        curB=curB.next;
      }
      return null;
      }
    }

```



