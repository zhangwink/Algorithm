# 代码随想录算法训练营第二十三天|[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/),[78. 子集](https://leetcode.cn/problems/subsets/)



> 状态:一刷
>
> 文档:[代码随想录](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)



---

## 题目:

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

示例 1：

- 输入：s = "25525511135"
- 输出：["255.255.11.135","255.255.111.35"]

**思路:**
这道题与分割回文串基本相同,类似于切割问题,利用回溯算法把所有可能性搜索出来,切割问题可以抽象为树形结构,如图:

![20201123203735933](https://file1.kamacoder.com/i/algo/20201123203735933.png)

**回溯三部曲:**

- **递归参数**

  startIndex是一定需要的,不能重复分割,要记录下一次分割的起点

  我们还需要一个pointNum,用来记录逗点的数量

  因此,代码如下:

  ```c++
  vector <string> result;
  //startIndex:搜索的起始位置,pointNum:添加逗点的数量
  void backtracking(string&s, int startIndex, int pointNum)
  ```

- **递归终止条件**

  终止条件:当逗点数量到三个位置,就是将字符串分成四块了

  因此,代码如下:

  ```c++
  if (pointNum == 3){
    //判断第四段字符串是否合法,如果合法就放进result中
    if (isValid(s,startIndex,s.size()-1)){
      result.push_back(s); 
    }
    return;
  }
  ```

- **单层搜索的逻辑**

  在for(i = startIndex; i < s.size(); i++)循环中[startIndex,i]这个区间就是截取的子串,需要判断这个子串是否合法

  如果合法就在子串后面加上符号,表示已经符合

  如果不合法就结束本层分支

  **然后就是递归和回溯的过程**

  递归调用时,下一层的startIndex要从i+2开始,因为已经加了一个,同时pointNum也要加1

  ,回溯的过程就讲新加入的,删除,并且num-1

  因此,代码如下:

  ```c++
  for (int i =startIndex; i< s.size; i++){
    if (isValid(s,startIndex,i)){
  		s.insert(s.begin() + i + 1,'.');
      pointNum++;
      backtracking(s,i+2,pointNum);
      pointNum--;
      s.erase(s.begin()+i+1);
    }
    else break;
  }
  ```

  ### 判断子串是否合法

  最后就是在写一个判断段位是否是有效段位了。

  主要考虑到如下三点：

  - 段位以0为开头的数字不合法
  - 段位里有非正整数字符不合法
  - 段位如果大于255了不合法

  代码如下：

```c++
// 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法
bool isValid(const string& s, int start, int end) {
    if (start > end) {
        return false;
    }
    if (s[start] == '0' && start != end) { // 0开头的数字不合法
            return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
            return false;
        }
        num = num * 10 + (s[i] - '0');
        if (num > 255) { // 如果大于255了不合法
            return false;
        }
    }
    return true;
}
```



---

### [78. 子集](https://leetcode.cn/problems/subsets/)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

回溯问题都可以将其抽象为树形结构



![78.子集](https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png)

从图中红线部分,可以看出遍历这个树的时候,把所有结点都记录下来就是要求的子集集合



**回溯三部曲:**

- **递归函数参数**

  代码如下:

  ```c++
  vector <vector<int>> result;
  vector<int> path;
  void backtracking (vector<int>& nums,int startIndex)
  ```

- 终止条件

![78.子集](https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png)

从图中可以看出:

剩余结点为空的时候,就是叶子结点

那么什么时候剩余集合为空呢?

就是遍历的startIndex已经大于数组的长度了,就终止,因为没有元素可以在取到了

因此,代码如下:

```cpp
if (startIndex >= nums.size()) {
    return;
}
```



- **单层递归逻辑**

  ```c++
  for (int i = startIndex; i < nums.size(); i++) {
      path.push_back(nums[i]);    // 子集收集元素
      backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取
      path.pop_back();            // 回溯
  }
  ```



---

## 总结:

**回溯算法模板:**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```





