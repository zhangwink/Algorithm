# 代码随想录算法训练营第二十一天|[77. 组合](https://leetcode.cn/problems/combinations/),[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

> 文档:[代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB)
>
> 状态:一刷

---



## 理论基础:

**回溯法:**

回溯法是回溯搜索法,一种搜索方式

二叉树中,递归也是一种隐藏的回溯



**回溯法的效率:**

回溯法并不是高效的算法,本质是穷举,然后选出想要的答案,

因此想要提高回溯法的效率,就要对其进行剪枝操作,但也改变不了回溯法就是穷举的本质



**回溯法解决的问题:**

- 组合问题:N个数里面按一定规则找出k个数的集合
- 切割问题:一个字符串按照一定规则有几种切割的方式
- 子集问题:一个N个数的集合有多少符合条件的子集
- 排列问题:N个数按一定规则全排列,集中排列方式
- 棋盘问题:



**回溯法结局的问题都可以抽象为树形结构**

集合的大小可以构成树的宽度,递归的深度可以构成树的深度



**对于回溯法也有固定的模版:**

```
void backtracking(参数){
	if (终止条件){
		存放结果
		return;
	}
	
	for ( 选择本层集合中的所有元素)「
		处理结点;
		backtracking(路径,选择列表);
		回溯,撤销处理结果
}
```

我们讲解了，什么是回溯算法，知道了回溯和递归是相辅相成的。

接着提到了回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。

然后列出了回溯法可以解决几类问题，可以看出每一类问题都不简单。

最后我们讲到回溯法解决的问题都可以抽象为树形结构（N叉树），并给出了回溯法的模板。

今天是回溯算法的第一天，按照惯例Carl都是先概述一波，然后在开始讲解具体题目，没有接触过回溯法的同学刚学起来有点看不懂很正常，后面和具体题目结合起来会好一些。



## 题目:

### [77. 组合](https://leetcode.cn/problems/combinations/)

可以把问题抽象为





![20201123195223940](https://file1.kamacoder.com/i/algo/20201123195223940.png)

可以看出一开始的集合为1234,从左向右取,不重复取出

n相当于树的宽度,k相当于树的深度



**回溯法三部曲:**

- 递归函数的返回值及参数

定义两个全局变量用来存放单一结果,一个用来存放结果的集合

函数里至少有两个参数,集合n里面取k个数,那么k和n是两个int型参数

然后需要一个数来限制本层递归里不重复相同元素

**代码如下:**

```C++
vector<vector<int>> result;
vector<int> path;
void backtracking(int n, int k, int startIndex)
```



- 回溯终止条件

path这个数组的大小如果到k就说明已经找到了一个子集大小为k的组合了

此时操作为用result把path存起来并停止递归

代码如下:

```c++
if(path.size() == k){
	result.push_back(path);
  return ;
}
```



- 单层搜索的过程

代码如下:

```c++
for (int i = startIndex; i<= n; i++){
  path.push_back(i);
  backtracking(n, k, i+1);
  path.pop_back();//回溯,撤销处理的结点
}
```



### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)







![20201123195717975](https://file1.kamacoder.com/i/algo/20201123195717975.png)

这道题和上一道题思路相同,只是加了一些条件



**回溯三部曲:**

- 确定递归函数参数

代码如下:

```c++
vector<vector<int>> result;
vector<int> path;
void backtracking (int targerSum, int k, int startIndex)
```



- 确定终止条件

这里比上一题要多一些限制

代码如下:

```c++
if (path.size == k){
	if (sum == target)result.push_back(path);
  return ;
}
```



- 单层搜索过程

代码如下:

```c++
for (int i=startIndex; i<=9; i++){
  sum+= i;
  path.push_back(i);
  backtracking(targetSum, k, sum, i+1);
  sum -= i;
  path.pop_back();
}
```



















































