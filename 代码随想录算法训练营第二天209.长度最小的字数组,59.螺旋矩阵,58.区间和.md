# 代码随想录算法训练营第二天|209.长度最小的字数组,59.螺旋矩阵,58.区间和



> 文档讲解:[**代码随想录**](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF)
>
> 视频讲解:[**代码随想录**](https://www.bilibili.com/video/BV1tZ4y1q7XE/?vd_source=536f01d8d7a74e18b43740216a40d3aa)
>
> 状态:一刷



## 题目:

### 209.[长度最小的字数组:](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

#### 第一想法:

第一想法是暴力解法 利用两层for循环 int i,j  i:从数组第一个元素开始 ;j:到数组最后一个元素结束

利用sum来计算i之后相加到哪里可以大于等于target 利用minLen来存放我要的数组长度

我的暴力循环代码为:

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
    	int n =nums.length;//数组长度
      int minLen = Integer.MAX_VALUE;
      
      for (int i=0;i<n;i++){
        int sum =0;
        for (int j=i;j<n;j++){
          sum +=nums[j];
          if (sum>=target){
            minLen=Math.min(minLen,j-i+1);
            break;
          }
        }
      }
      return minLen == Integer.MAX_VALUE ? 0;minLen;
    }

}
```



#### 看完随想录之后:

学会使用滑动窗口:窗口利用j(结束元素)从i位置开始 一直找到sum+=nums[j]的值大于等于target

然后开始**移动元素开始位置**(重点)

简单来说先用结束位置来确定一个窗口的大小 在用开始位置移动来逐步筛查大小

代码如下:

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
    	int left =0;
      int sum =0;
      int result =Integer.MAX_VALUE;
      for(int right =0;right<nums.length;right++){
				sum+=nums[right];
        while(sum>=target){
					result=Math.min(result,right-left+1);
          sum-=nums[left++];
        }
      }
        return result ==Integer.MAX_VALUE ? 0:result;
    }

}

```

### 59.螺旋矩阵

#### 第一想法:不会

#### 看完随想录之后:

利用边界左闭右开思路对每条边进行处理

代码如下:

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] nums = new int[n][n];
        int startX = 0, startY = 0;  // 每一圈的起始点
        int offset = 1;
        int count = 1;  // 矩阵中需要填写的数字
        int loop = 1; // 记录当前的圈数
        int i, j; // j 代表列, i 代表行;

        while (loop <= n / 2) {

            // 顶部
            // 左闭右开，所以判断循环结束时， j 不能等于 n - offset
            for (j = startY; j < n - offset; j++) {
                nums[startX][j] = count++;
            }

            // 右列
            // 左闭右开，所以判断循环结束时， i 不能等于 n - offset
            for (i = startX; i < n - offset; i++) {
                nums[i][j] = count++;
            }

            // 底部
            // 左闭右开，所以判断循环结束时， j != startY
            for (; j > startY; j--) {
                nums[i][j] = count++;
            }

            // 左列
            // 左闭右开，所以判断循环结束时， i != startX
            for (; i > startX; i--) {
                nums[i][j] = count++;
            }
            startX++;
            startY++;
            offset++;
            loop++;
        }
        if (n % 2 == 1) { // n 为奇数时，单独处理矩阵中心的值
            nums[startX][startY] = count;
        }
        return nums;
    }
}


```

**这个之后还得温习,对于这个问题的解决需要多练**

### 58.[区间和](https://kamacoder.com/problempage.php?pid=1070):

#### 第一想法:

我开始想到的就是暴力解法:先接收整数数组长度,再利用数组接受后面的元素我的想法是在用i和j分别接受起始和结束然后计算最后输出元素总和;

我的代码如下:

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt(); // 数组长度
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        
        // 读取区间直到输入结束
        while (sc.hasNextInt()) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            
            int sum = 0;
            for (int i = l; i <= r; i++) { // 暴力求和
                sum += arr[i];
            }
            System.out.println(sum);
        }
        
        sc.close();
    }
}

```

#### 看完随想录之后:

可以利用前缀和,来减少重复以提高效率

```java
import java.util.Scanner;

public calss Main{
  
  public static void main(){
    Scanner scanner =new Scanne3r (System.in);
    
    int n =scanner.nextInt();
    int [] vec = new int [n];
    int [] p=new int [n];
    
    int presum =0;
    for (int i=0;i<n;i++){
      vec[i]=scanner.nextInt();
      presum=vector[i];
      p[i]=presum;
    }
    
    while (Scanner.hasNextInt()){
      int a =scanner.nextInt;
      int b =scanner.nextInt;
      
      int sum;
      if (a==0){
        sum=p[b];
      }else{
        sum=p[b]-p[a-1];
      }
      sout
    }
    scanner.close
  }
}
```

### 总结:

通过今天的学习 学会了螺旋矩阵的边界管理 利用窗口滑动来确定最小字数组 学习区间和 前缀法的效率 

(今天忙,明天要重温)

