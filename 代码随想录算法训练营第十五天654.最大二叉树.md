# 代码随想录算法训练营第十五天|654.最大二叉树

## 题目:

### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

递归三部曲

1.确定函数的参数和返回值

这里需要返回的是二叉树的头结点,参数传入的事存放元素的数组

```c++
TreeNode * constructMAximumBinaryTree (vector <int> &nums)
```



2.确定终止条件

当数组中元素大小==1的时候即是叶子结点

```c++
TreeNode * node =new TreeNode (0);
if (nums.size == 1){
  node ->val =nums[0];
  return node ;
}
```



3.确定单层递归逻辑

- 先找到数组中最大的值和对应的下标,用最大值构造根结点,下表用来下一步分割数组

```c++
int maxValue =0;
int maxValueIndex =0;
for (int i =0; i<nums.size; i+){
  if (nums[i] > maxValue){
		maxValue =nums [i];
    maxValueIndex =i ;
  }
}
TreeNode * node = new TreeNode (0);
node->val =maxValue;
```



- 最大值所在的下标左区间构造左子树

  ```c++
  if (maxValueIndex > 0){
    vector <int> newVec(nums.begin(),nums.begin() + maxValueIndex);
    node -> left =constructMaximumBinaryTree (newVec);
  }
  ```

- 最大值所在的下标有区间 构造右子树

​	

```c++
if (maxValueIndex < (nums.size() -1)){
  vector <int> newVec (nums.begin() +maxValueIndex +1 ,nums.end());
  node ->right =constructMaximumBinaryTree(newVec);
}
```

