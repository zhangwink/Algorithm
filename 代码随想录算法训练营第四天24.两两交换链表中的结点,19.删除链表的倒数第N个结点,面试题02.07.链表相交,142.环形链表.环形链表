# 代码随想录算法训练营第四天|24.两两交换链表中的结点,19.删除链表的倒数第N个结点,面试题02.07.链表相交,142.环形链表

> 文档学习:[代码随想录](https://docs.qq.com/doc/DUFNjYUxYRHRVWklp?nlc=1)
>
> 视频学习:[代码随想录](https://www.bilibili.com/video/BV1YT411g7br/?vd_source=536f01d8d7a74e18b43740216a40d3aa)
>
> 状态:

## 题目:

### 24.[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/):

第一想法:

这个和前面的206有点像,都是逆转链表的思路

看完代码随想录:

想的差不多 主要问题在于不知道何时停止 继续移动

```java
class Solution{
  public ListNode swapPairs(ListNode head){
    ListNode dummyHead =new LIstNode (-1);
		dummyHead.next=head;
    ListNode cur =dummyhead;
    ListNode tmp;//临时结点 保存两个结点后面的结点
    ListNdoe firstNode ;//临时结点 保存两个结点中的第一个结点
    ListNode secondNode ;//临时结点 保存两个结点中的第二个结点
    while (cur.next!=null&&cur.next.next!=null){
      tmp=cur.next.next.next;
      firstNode=cur.next;
      secondNode=cur.next.next;
      cur.next=secondNode;
      secondNode.next=firstNode;
      firstNode.next=tmp;
      cur=firstNode;
    }
    return dummyHead.next;
  }
}
```

这个递归版本我还没看 ,今天有点忙 先到这里

```java
// 递归版本
class Solution {
    public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```

