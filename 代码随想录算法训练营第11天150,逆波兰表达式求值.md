# 代码随想录算法训练营第11天|150,逆波兰表达式求值

> 文档:[代码随想录](https://docs.qq.com/doc/DUHh6UE5hUUZOZUd0?nlc=1)
>
> 状态:一刷



## 题目:

### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)



![代码随想录-7](/Users/zzp/Downloads/代码随想录-7.jpg)



### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![239.滑动窗口最大值](https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif)

对于窗口里的23514 只需要维护54

pop(value):如果窗口移除的元素value==单调队列的出口元素,那么队列弹出元素,否则不进行任何操作

push(value):如果push元素value大于入口元素的数值,那么就将队列入口元素弹出,知道push的元素小于队列入口元素的数值为止

![239.滑动窗口最大值-2](https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif)

代码如下:

```java
class MyQueue{
  Deque<Integer>deque =new LinkedList<>();
  
  void poll(int val){
    if (!deque.isEmpty()&&val==deque.peek()){
      deque.poll();
    }
  }
  
  void add (val){
    while (!deque.isEmpty()&&val>deque.getLast()){
      deque.removeLast();
    }
    deque.add(val);
  }
  
  int peek(){
    return deque.peek();
  }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
     	if (nums.length==1){
        return nums;
      }   
      int len =nums.length-k+1;
      //存放结果的元素
      int [] res =new int [len];
      int num=0;
      
      //自定义队列
      MyQueue myQueue =new MyQueue();
      //先将前k个元素放入队列
      for (int i=0; i<k; i++){
        myQueue.add(nums[i]);
      }
      res[nums++]=myQueue.peek();
      for (int i =k; i<nums.length; i++){
				myQueue.poll(nums[i-k]);
        myQueue.add(nums[i]);
        res[nums++]=myQueue.peek();
      }
      return res;
    }
}
```

