# 代码随想录算法训练营第十九天|[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/),[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/),[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

> 文章:[代码随想录]()
>
> 状态:1刷

## 题目:

### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)



![20201018172243602](https://file1.kamacoder.com/i/algo/20201018172243602.png)

给定的这个二叉搜索树:root = [6,2,8,0,4,7,9,null,null,3,5]

if p=2 q=8 输出公共祖先为6

2和4输出公共祖先为2



**思路**

因为这个树为二叉搜索树 使用中序遍历类似于[268]这种格式 所以公共祖先cur 位置在 cur->val >=p->val &&cur->val<=q->val; 因此按这种方向就能找到公共祖先

**递归三部曲**:

- 确定递归函数参数及返回值

​	参数为当前结点,返回公共祖先

代码如下:

```c++
TreeNode * traversal (TreeNode * cur ,TreeNode * p,TreeNode*q)
```

- 确定终止条件
  - 遇到空返回即可

代码如下:

```c++
if (cur == NULL) return cur;
```

- 确定单层递归逻辑
  - 再遍历二叉搜索树的时候寻找区间[p->val,q->val]区间的值
  - 如果cur->val大于p->val&&cur->val >q->val因此要向左遍历

代码如下:

```c++
if (cur->val >p->val && cur->val >q->val){
  TreeNode *left =traversal(cur->left,p,q);
  if (left!=NULL){
    return left;
  }
}
if (cur->val <p->val && cur->val <q->val){
  TreeNode *right =traversal(cur->right,p,q);
  if (right!=NULL){
    return right;
  }
}
return cur;

```

### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

![20201019173259554](https://file1.kamacoder.com/i/algo/20201019173259554.png)

**思路**:

对于这个插入二叉树 可以有如图很多种变型 但是可以不考虑变型,只需要在末尾结点插入就可以

只需要遍历二叉搜索树,找到符合位置的末尾结点插入

**递归三部曲**

- 确定函数递归参数即返回值
  - 参数就是结点指针,以及要插入的元素,返回TreeNode*

代码如下:

```c++
TreeNode* insertIntoBST (TreeNode* root, int val)
```

- 确定终止条件
  - 终止条件就是找到遍历的结点为null的时候,就是要插入结点的位置,并把插入的结点返回

代码如下:

```c++
if (root ==NULL){
  TreeNode* node =new TreeNode(val);
  return node;
}
```

- 确定单层递归逻辑
  - 搜索树是有方向的,可以根据插入元素的数值,决定递归方向

代码如下:

```c++
if (root->val >val) root->left = insertIntoBST (root ->left ,val);
if (root->val <val) root->right = insertIntoBST (root ->right ,val);
return root;
```

### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

![20201020171048265](https://file1.kamacoder.com/i/algo/20201020171048265.png)

**思路:**

搜索树的删除会有很多结构的变化,因此要考虑多种情况

**递归三部曲:**

- 确定函数递归的参数及其返回值

代码如下:

```c++
TreeNode* deleteNode (TreeNode*root ,int key)
```

- 确定终止条件
  - 遇到空返回,说明没有找到删除的结点,遍历到空结点直接返回了

代码如下:

```c++
if (rot == nullptr) return root;
```

- 确定单层递归的逻辑

  需要把二叉搜索树删除结点遇到的情况全部考虑

  - 第一种情况:没找到删除的结点,遍历到空结点直接返回了
  - 第二种情况:左右孩子都为空,直接删除结点,返回null
  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - 第五种情况:左右孩子都不为空,则将删除结点的左子树移到删除结点的右子树的最左面结点的左孩子上,返回删除结点的右孩子为根结点

  ![450.删除二叉搜索树中的节点](https://file1.kamacoder.com/i/algo/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif)

代码如下:

```c++
TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
```





## 总结:

今天学习了二叉搜索树的公共祖先,学会使用中序遍历获取区间来寻找公共祖先,=

学会了二叉树的插入结点,不需要复杂的变形,直接遍历二叉搜索树去寻找符合位置的末尾结点加上去即可

学会了二叉树的删除结点,需要考虑五种情况,针对不同情况进行设计,尤其是第五种,待删除结点的左右孩子都不为空的情况,将删除结点的左子树移到删除结点的右子树最左边结点成为其左孩子,来应对

