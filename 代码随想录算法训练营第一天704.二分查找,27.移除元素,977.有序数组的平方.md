

# *代码随想录算法训练营第一天|*704.二分查找,27.移除元素,977.有序数组的平方





---

> 文档讲解:[代码随想录](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)
>
> 状态:浏览完文档,视频未刷

## 导语:

​	今天是算法训练营的第一天，我从数组的基本概念开始，理解了为什么删除元素需要移动其他值的原因；随后复习了二分查找的左闭右闭和左闭右开区间写法，体会到了边界控制的重要性；最后用双指针方法解决了有序数组平方的问题。整个过程让我逐步体会到“算法不仅是代码，更是一种思维方式“

---



## 学习内容:

#### [数组理论基础](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html):

1. 数组是存放在**连续内存空间**上的**相同数据类型**的集合
2. 数组可以方便的通过下索引的方式获取到下标对应的数据
   - 数组下标都是从0开始的
   - 数组内存空间的地址是连续的
     - 也正因为数组内存空间是连续地址是连续的,所以我们在删除或者增加元素的时候,就难免要移动其他元素的地址
     - 并且数组元素的数据没有删除一说,准确的来讲是覆盖

#### [二分查找](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE):

- 左闭右闭的区间:while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
- 左闭右开的区间:while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

#### [双指针法](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF):

- 快慢双指针法:通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
- 快指针:寻找新数组不含有目标元素的数组(27移除元素);
- 慢指针:指向更新数组下标的位置





---



## 题目

### 第一想法:

#### 704.[二分查找](https://leetcode.cn/problems/binary-search/)

​	作为第一次接触到这个题我还是有思路的:

​		因为题目是二分查找并且说明已经对元素进行了升序,因此我不用对其进行排序只需要专注于找到目标元素的下标即可,我本来可以选择按顺序查找O(n)for循环一个一个查找 但是题目要求O(logn)因此需要二分查找,这就是我的代码思路



**自己写的左闭右闭区间**

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length - 1;
        int left = 0;
        int right = n;
        int mid = 0;

        while(left<=right){
            mid = left + (right-left)/2;
            if (target < nums[mid] ){
                right = mid - 1;
            }

            if (target > nums[mid]){
                left = mid + 1;
            }

            if (target == nums[mid]){
                return mid;
            }
        }
        return -1;
    }
}
```

**自己写的左闭右开区间**

```java
class Solution {
    public int search(int[] nums, int target) {
        // 可选提前判断
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }

        int left = 0;
        int right = nums.length; // 左闭右开区间 [left, right)

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (target < nums[mid]) {
                right = mid;    // 收缩右边界
            } else {
                left = mid + 1; // 收缩左边界
            }
        }

        return -1; // 没找到
    }
}

```

#### 27,[移除元素](https://leetcode.cn/problems/remove-element/description/)

第一次想到的就是遍历循环 然后找到相同的然后删除对应元素 ,还不会使用双指针

```java
//暴力解法
class Solution {
    public int removeElement(int[] nums, int val) {
        int n =nums.length;
        for (int i=0;i<n;i++){
            if (nums[i]==val){
                for (int j=i+1;j<n;j++){
                    nums[j-1]=nums[j];
                }
                i--;
                n--;
            }
        }
        return n;
    }
}
```

#### 977.[有序组数的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

第一眼看到的时候认为应该先for循环对每个数组元素平方,最后在排序

```java
//暴力解法
class Solution {
    public int[] sortedSquares(int[] nums) {
        for (int i=0;i<nums.length;i++){
          nums[i]=nums[i]*nums[i];
        }
      Arrays.sort(nums);
      return nums;
    }
}
```

 



### 看完代码随想录:

704:

```java
//（版本一）左闭右闭区间
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            }
            else if (nums[mid] < target) {
                left = mid + 1;
            }
            else { // nums[mid] > target
                right = mid - 1;
            }
        }
        // 未找到目标值
        return -1;
    }
}
```

```
首先我原本的代码中没有
if(target<nums[0]||target>nums[nums.length-1])这个很重要 可以避免target多次循环计算
其次我并没有用else if语句链接 我的三个 if 是并列的，每次循环会判断三次 用elseif会提高效率
```

```java
//（版本二）左闭右开区间
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            }
            else if (nums[mid] < target) {
                left = mid + 1;
            }
            else { // nums[mid] > target
                right = mid;
            }
        }
        // 未找到目标值
        return -1;
    }
}
```

27.删除元素

```java
class Solution {
    public int removeElement(int[] nums, int val) {
      int slowIndex=0;
      for (int fastIndex=0;fastIndex<nums.length;fastIndex++){
				if (nums[fastIndex]!=val){
					nums[slowIndex]=nums[fastIndex];
          slowIndex++;
        }
      }
      return slowIndex;
    }  
}
```

977.有序数组的平方

看完之后想法:

题目给的非递减顺序,因此数组要拍完之后的最大值就是单个数字的最大值 对于负数来说就是绝对值的最大值 因此 数组的最大值就在原本递减数组中最两边的位置,可以用双指针来解,定义两边的指针 判断两边绝对值 也可以判断平方后的大小 来决定哪个先放入 

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
     	int right=nums.length -1;
      int left =0;
      int []result =new int [nums.length];//new一个一模一样大的数组出来存放新的元素
      int index=result.length-1;//因为双指针是从两边开始的所以元素从最大开始排因此 我需要从新数组最左边排列
      while(left<=right){
				if (nums[left]*nums[left]>nums[right]*nums[right]){
					result[index--]=nums[left]*nums[left];
          left++;
        }else{
          result[index--]=nums[right]*nums[right];
          right--;
        }
      }
      return result;
    }
}
```



### 实现过程遇到的困难

---

​	我在编写代码时,不能自己流利地用编程语言把脑子里想的编译出来 还需要借助卡哥代码理解 对双指针思路以前理解不通透导致无法利用双指针提高效率

## 今日收获

- 系统复习了 **数组的存储特性**，理解了为什么增删元素会影响内存和下标；
- 掌握了 **二分查找的两种区间写法**（左闭右闭 / 左闭右开），理解了循环条件和边界调整的逻辑差异；
- 学会了 **双指针技巧**，不仅能优化删除元素问题，也能高效解决有序数组平方的问题；
- 通过暴力解法到优化解法的实践